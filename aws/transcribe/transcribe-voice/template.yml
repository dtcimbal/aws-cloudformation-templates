AWSTemplateFormatVersion: 2010-09-09
Description: The AWS CloudFormation template for voice transcription Lambda
Parameters:
  VoiceBucketName:
    Description:      The S3 bucket name to hold voice file for transcription
    Type:             String
    Default:          tweexy-voice
  TranscriptionBucketName:
    Description:      The S3 bucket name to hold the result transcriptions
    Type:             String
    Default:          tweexy-transcriptions
Resources:
  VoiceBucket:
    Type: AWS::S3::Bucket
    DependsOn:
    - TranscriptionLambdaFunction
    Properties:
      BucketName: !Ref VoiceBucketName
      NotificationConfiguration:
        LambdaConfigurations:
        - Event: "s3:ObjectCreated:*"
          Function: !GetAtt TranscriptionLambdaFunction.Arn

  VoiceBucketNotificationPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref VoiceBucket
      PolicyDocument:
        Statement:
        - Effect: "Allow"
          Action:
          - s3:PutBucketNotification
          Resource: !GetAtt VoiceBucket.Arn
          Principal:
            AWS: !GetAtt TranscriptionExecutionRole.Arn

  TranscriptionLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: 'lambda:InvokeFunction'
      FunctionName: !GetAtt TranscriptionLambdaFunction.Arn
      Principal: 's3.amazonaws.com'
      # Direct Arn will create a cyclic reference
      # SourceArn: !GetAtt VoiceBucket.Arn
      SourceArn: !Sub 'arn:aws:s3:::${VoiceBucketName}'

  TranscriptionBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref TranscriptionBucketName
  TranscriptionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: voice-transcription-role
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Policies:
      - PolicyName: log-voice-transcription-policy
        PolicyDocument:
          Version: 2012-10-17
          Statement:
          - Effect: "Allow"
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            Resource:
            - !Sub >-
              arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*
      - PolicyName: s3-get-voice-transcription-policy
        PolicyDocument:
          Version: 2012-10-17
          Statement:
          - Effect: Allow
            Action:
            - s3:GetObject
            Resource:
            - !Sub >-
              arn:aws:s3:::${VoiceBucketName}/*
      - PolicyName: s3-put-voice-transcription-policy
        PolicyDocument:
          Version: 2012-10-17
          Statement:
          - Effect: Allow
            Action:
            - s3:PutObject
            Resource:
            - !Sub >-
              arn:aws:s3:::${TranscriptionBucketName}/*
      - PolicyName: transcribes-policy
        PolicyDocument:
          Version: 2012-10-17
          Statement:
          - Effect: Allow
            Action:
            - transcribe:GetTranscriptionJob
            - transcribe:StartTranscriptionJob
            - transcribe:CreateVocabulary
            - transcribe:DeleteVocabulary
            - transcribe:ListVocabularies
            - transcribe:GetVocabulary
            Resource: '*'
      Path: /


  TranscriptionLambdaFunction:
    Type: AWS::Lambda::Function
    DependsOn:
    - TranscriptionExecutionRole
    Properties:
      Handler: !Sub 'index.handler'
      MemorySize: 256
      Role: !GetAtt TranscriptionExecutionRole.Arn
      Runtime: python3.6
      Timeout: 300
      Environment:
        Variables:
          TranscriptionBucket: !Ref TranscriptionBucketName
      Code:
        ZipFile: |
          import logging
          import os
          import random
          import re
          import string
          import urllib.parse

          import boto3
          from botocore.config import Config

          # Log level
          logging.basicConfig()
          logger = logging.getLogger()
          logger.setLevel(logging.DEBUG)

          logger.info('Loading function')

          config = Config(
              retries=dict(
                  max_attempts=2
              )
          )

          transcribe = boto3.client('transcribe', config=config)

          MEDIA_FORMAT_LOOKUP = {
              "flac": "",
              "mp3": "",
              "mp4": "",
              "wav": ""
          }


          class UnsupportedMediaFormatError(ValueError):
              pass


          class ThrottlingException(Exception):
              pass


          def check_supported_media_format(format):
              if format not in MEDIA_FORMAT_LOOKUP:
                  raise UnsupportedMediaFormatError(format + " is not supported audio type.")


          # Generates a random ID for the transcribe function execution
          def gen(size=8, chars=string.ascii_uppercase + string.digits):
              return ''.join(random.choice(chars) for _ in range(size))


          def handler(event, context):
              try:
                  session = boto3.session.Session()
                  region = session.region_name

                  job_name = gen()

                  # Get the object from the event and show its content type
                  bucket = event['Records'][0]['s3']['bucket']['name']
                  key = urllib.parse.unquote_plus(event['Records'][0]['s3']['object']['key'], encoding='utf-8')

                  # Assemble the url for the object for transcribe. It must be an s3 url in the region
                  url = "https://s3-" + region + ".amazonaws.com/" + bucket + "/" + key
                  ext = re.search('\.(\w{3,4})$', key).group(1)

                  check_supported_media_format(ext)
                  logger.info("media type: " + ext)

                  transcriptionBucket = os.environ['TranscriptionBucket']

                  # Request the transcription job.
                  response = transcribe.start_transcription_job(
                      TranscriptionJobName=job_name,
                      LanguageCode='en-US',
                      OutputBucketName=transcriptionBucket,
                      MediaFormat=ext,
                      Media={
                          'MediaFileUri': url
                      },
                      Settings={
                          'ShowSpeakerLabels': True,
                          'MaxSpeakerLabels': 10,
                          'ChannelIdentification': False
                      }
                  )
                  is_successful = "TRUE"
              except transcribe.exceptions.BadRequestException as e:
                  # There is a limit to how many transcribe jobs can run concurrently. If you hit this limit,
                  # return unsuccessful and the step function will retry.
                  logger.error(str(e))
                  raise ThrottlingException(e)
              except transcribe.exceptions.LimitExceededException as e:
                  # There is a limit to how many transcribe jobs can run concurrently. If you hit this limit,
                  # return unsuccessful and the step function will retry.
                  logger.error(str(e))
                  raise ThrottlingException(e)
              except transcribe.exceptions.ClientError as e:
                  # Return the transcription job and the success code
                  # There is a limit to how many transcribe jobs can run concurrently. If you hit this limit,
                  # return unsuccessful and the step function will retry.
                  logger.error(str(e))
                  raise ThrottlingException(e)
              return {
                  "success": is_successful,
                  "transcribeJob": job_name
              }
